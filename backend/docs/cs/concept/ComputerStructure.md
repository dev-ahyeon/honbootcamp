## 📘 Week 01 – 컴퓨터 구조

## 🎯 왜 컴퓨터 구조를 알아야 하나?

> 단순한 최적화가 아니라, "어디서 병목이 발생했는가?"를 구조적으로 추적할 수 있어야 한다.

---

### 💡 실무 상황과 컴퓨터 구조 개념 연결

| 실무 상황                                             | 관련 컴퓨터 구조 개념                          | 설명 요약                                                   |
|----------------------------------------------------|------------------------------------------|------------------------------------------------------------|
| Redis 캐시를 써도 서비스가 느림                             | 캐시 계층 구조 (CPU 캐시 ↔ RAM ↔ 디스크)     | Redis는 RAM 기반, 그러나 L1~L3 캐시 미스로 병목 발생 가능성               |
| CPU 사용률이 800%인데도 여전히 느림                        | 멀티코어/하이퍼스레딩 구조, 파이프라이닝 병목        | 8코어라면 100% × 8 = 800% 사용 중 → 코어 활용 구조 이해 필요         |
| Docker 컨테이너 실행 시 `exec format error` 발생      | ISA (x86 vs ARM), 명령어 집합 호환성            | 플랫폼 아키텍처가 맞지 않아 실행 실패 (ex. M1에서 x86 이미지 실행 시도)   |
| 스프링 서비스 배포 후 CPU 점유율 급등                       | JVM 내부 구조, JIT 컴파일, GC, 명령어 사이클      | 실행 중 클래스 로딩, JIT 컴파일, GC 동작이 CPU에 영향               |
| 로그 상으로는 이상 없음 → 실서비스에서는 지연 발생             | NUMA 메모리 구조, 지역성 (locality), 캐시 미스    | NUMA 지역 간 거리 차이로 인한 메모리 접근 속도 차이 발생               |

---

### 🧩 컴퓨터 구조를 알면 가능한 실무 능력

- ✅ **병목의 원인과 위치를 정확히 분석할 수 있음**
- ✅ **JVM, Docker, WAS의 성능 저하 원인을 하드웨어 수준에서 해석 가능**
- ✅ **멀티스레딩/비동기 설계 시 코어 활용 및 컨텍스트 스위칭 효율 고려 가능**
- ✅ **불필요한 오버스펙 방지 → 서버 비용 최적화**
- ✅ **문제 발생 시 로그에 나오지 않는 레벨(캐시/버스/메모리)을 추적할 수 있음**

---

### ✨ 개발자에게 필요한 관점 전환

> ❌ "응답이 느리다 → 코드 문제인가?"  
> ✅ "응답이 느리다 → 어느 구조에서 병목인가? (CPU? RAM? 디스크? 네트워크?)"
---

### Go Go ~~  

<br>

### 🧠 CPU (Central Processing Unit)

- 컴퓨터의 두뇌 역할. 모든 **연산과 명령어 처리**를 담당.
- 프로그램의 명령어를 받아 해석(Decode)하고, 실행(Execute)함.
- CPU 내부에는 ALU(산술 논리 장치), CU(제어 장치), 레지스터 등 포함됨.

#### 실무 연결
- 서버가 느려질 때 `CPU 사용률`, `Context Switching`, `스레드 대기` 등을 분석해야 함.
- 스레드가 많다고 무조건 빠르지 않음 → **CPU 구조에 맞게 설계**해야 함.

---

### ⚙️ 코어 (Core)

- CPU 내의 **독립적인 연산 유닛**.
- 과거에는 CPU 하나에 코어 하나였지만, 현재는 다중 코어 (듀얼, 쿼드, 옥타 등) 구조가 일반적.
- 각 코어는 **자신의 명령어를 독립적으로 실행** 가능.

#### 실무 연결
- `8코어` 서버에서 하나의 쓰레드만 사용하는 구조라면 **7코어는 놀고 있음**.
- Spring 비동기 처리, 멀티스레드 프로그래밍 시 코어 활용도를 고려해야 함.

---

### 🧵 스레드 (Thread)

- 프로세스 내부의 **실행 단위**. 하나의 프로세스 안에 여러 스레드 존재 가능.
- 메모리(Heap 등)는 공유하지만, **스택(Stack)은 개별적으로 사용**함.
- 자바에서는 `Thread`, `Runnable`, `ExecutorService` 등으로 구현.

#### 실무 연결
- 스레드 수가 많을수록 컨텍스트 스위칭 오버헤드 증가 → 오히려 성능 저하 가능성.
- `스레드 수 > 코어 수`일 경우 → CPU는 스케줄링 부담, 캐시 미스 증가.

---

### 💡 요약 관계

| 개념     | 정의                             | 메모리 영역        | 실무 팁                                        |
|--------|--------------------------------|----------------|---------------------------------------------|
| CPU    | 연산과 명령어 처리 장치                | 전체 제어/계산     | 병목 시 `top`, `perf`, `jvisualvm`으로 분석     |
| 코어    | CPU 내부의 실행 유닛                  | 개별 연산 유닛     | `taskset`, `numactl`로 지정 사용 가능             |
| 스레드   | 프로세스 내부의 실행 흐름 단위            | Stack (개별), Heap (공유) | 너무 많은 스레드는 오히려 성능 저하             |


#### ✅ 하이퍼스레딩 / SMT

* 1개의 코어가 2개의 스레드를 병렬 처리 (논리 CPU)
* 실질적 성능 향상, 다중 요청 처리 효율 증가

#### ✅ 캐시 구조 (L1/L2/L3)

* CPU 내부에 있는 고속 메모리
* L1 (가장 빠름, 가장 작음) → L2 → L3 → RAM
* 캐시 미스 시 성능 급락 → 메모리 접근 시간 증가

#### ✅ 명령어 사이클 & 파이프라이닝

* F → D → E → M → W (Fetch → Decode → Execute → Memory → Writeback)
* 파이프라이닝: 명령어를 나눠 병렬 처리 (성능 향상)
* 병목 발생 시: Stall, Flush 현상 발생 가능

#### ✅ 메모리 계층 구조

```
레지스터 < L1 < L2 < L3 < RAM < SSD < HDD
(속도 ↑, 용량 ↓)
```

* 적중률(Cache Hit)이 성능의 핵심 지표

#### ✅ 버스 구조

* 주소 버스: 메모리 주소 전달
* 데이터 버스: 데이터 이동
* 제어 버스: 제어 신호 전달

#### ✅ NUMA 구조 (Non-Uniform Memory Access)

* 멀티 소켓 CPU 환경에서 메모리 접근 속도 다름
* `numactl`, `taskset`으로 메모리 지역성 관리 가능

#### ✅ ISA (Instruction Set Architecture)

* x86, ARM 등 서로 다른 명령어 체계
* 이식성 문제 발생 가능 → Docker, 배포 시 주의 필요

#### ✅ JVM 관점에서의 구조

* Heap / Stack / Metaspace 영역 구분
* Full GC 발생 시 CPU 사용률 급등 → GC 로그로 확인 가능
* JIT 컴파일, HotSpot 영역 분석 필요

---

### 🛠 실습 도구 요약

| 도구/명령어            | 설명                   |
| ----------------- | -------------------- |
| `jvisualvm`       | Java CPU 병목 분석 도구    |
| `htop`, `top`     | 실시간 CPU/메모리/스레드 모니터링 |
| `taskset`         | 특정 CPU 코어에 프로세스 고정   |
| `numactl`         | NUMA 메모리 접근 제어       |
| `perf`, `vmstat`  | 시스템 성능 분석            |
| `redis-benchmark` | Redis 성능 측정 도구       |
| `pidstat`         | PID별 CPU/메모리 상세 추적   |
| `flamegraph`      | CPU 사용 패턴 시각화        |

---

### 🧪 실습 예제

1. **Redis 캐시 vs 비적용 비교**

    * 캐시 적용 전/후 응답속도 비교 (단일 요청, 대량 요청)
    * TTL 설정, LRU 동작 확인

2. **Java CPU 병목 분석**

    * 무한 루프 실행 후 jvisualvm으로 스레드 상태/CPU 소비 분석

3. **멀티 코어 활용 실험**

    * taskset으로 코어 고정 → 처리 속도 비교
    * 비동기/멀티스레드 구조와 CPU 점유율 분석

4. **Docker ISA 충돌 테스트**

    * ARM 기반에서 x86 이미지 실행 실패 재현
    * `docker buildx`로 멀티 플랫폼 빌드 실험

5. **파이프라이닝 병목 재현 실험**

    * 명령어 간 의존성으로 인한 Stall 유도 코드 작성
    * 캐시 miss를 발생시키는 접근 패턴 구현 (대용량 순차 접근 vs 랜덤 접근)

---

### 🧭 병목 분석 흐름 예시 (실전 대응)

```
[문제] 서버가 느리다
 → top: CPU 100%? → jvisualvm: 특정 스레드 점유?
   → GC spike? → 코드 hotspot? → 캐시 미스? → DB I/O?
```

---

> ✅ 실무 핵심 정리: "성능 문제의 원인을 추정하지 말고 구조적으로 추적하라."
